==========================================
 rmalloc: Relocatable Memory Allocator
==========================================
:Author: Mikael Jansson <mail@mikael.jansson.be>

.. contents::

Purpose
=======
To write and benchmark a special-purpose allocator that can compact its heap,
while still being fast enough for usage within the web browser Opera.

What
====
The purpose of |rmalloc| is to provide the ability to perform compacting of the
application heap, by making memory access indirect, e.g.::

    status_t rmalloc(memory_t **, ssize_t);
    status_t rmlock(memory_t *, void **);
    status_t rmunlock(memory_t *);
    status_t rmfree(memory_t *);

Example::

    #define WIDTH 100
    #define HEIGHT 100

    /* allocate memory for the bitmap */
    memory_t *bitmap;
    rmalloc(&bitmap, WIDTH*HEIGHT);

    /* get reference to actual memory */
    unsigned char *ptr;
    rmlock(bitmap, (void **)&ptr);

    /* draw pattern */
    for (y=0; y<HEIGHT; y++)
        for (x=0; x<WIDTH; x++)
            ptr[x + y*WIDTH] = x^y;

    /* release pointer and call auxillary code to do something with memory */
    rmunlock(bitmap);
    draw_bitmap(bitmap);

    /* done with the bitmap, release allocated memory */
    rmfree(bitmap);

Meta-How
==========
Three steps, of which the two last ones are iterative: 

#. Gather allocation statistics from real-world usage of Opera
#. Benchmark current allocators against |rmalloc|, by feeding data from the
   previous step into the allocators.
#. Tweak |rmalloc|.

Benchmarking
~~~~~~~~~~~~~~
Because of the difference in usage between |rmalloc| and standard allocators,
the standard allocators will be wrapped such that they can be plugged in as
direct replacements for |rmalloc|. 

How
====
Allocation status of a picee of memory is set in memory_block_t::used. An
allocation sets the value to true, a free sets it to false. 
Memory blocks are stored together with the allocated spcaes.  Memory handles
are currently also stored together with the user data. 

There are two options for giving back memory when freeing memory handles:

1. Add a member to memory_t, used, for next collection.
2. Reserve a place in RAM for storing only memory_ts, on the assumption that
   there will be a maximal number of memory chunks allocated.

For #2, we need to know the typical memory size requested by the application.
In general, this is unknown, but as this allocator is going to be used in a
special-purpose setting, that value cna be found out.

Given the following variables.

:R: Total amount of memory currently available for use by the allocator
:M: Size of each piece of user-allocated memory
:D: Overhead (i.e. size of internal data sructures) associated with each
    user-allocated memory chunk.


2008-07-14
===========
Been sick for the past week, so the time schedule is delayed by one week.

Simple start, double-linked list stores the memory chunks and the info about
them. User-exposed structure keeps a pointer plus the number of locks held.
Lot of overhead currently, more efficient to store memory blocks as an array
to avoid the two pointers that make up the double-linked list.  Optionally,
could use a single-linked list.   without the link pointers, place the
structures at the very end of the memory and grow downwards, towards the
memory (i.e. stack).  this is better than placing them in the beginning,
because either space will be lost, or too little space is preserved and the
memory chunks have to be moved around.

a merge of two adjacent free blocks 


|rmalloc| replace:: ``rmalloc``

.. vim:syntax=rst
